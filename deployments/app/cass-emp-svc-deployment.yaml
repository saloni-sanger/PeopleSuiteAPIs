apiVersion: v1
kind: Service
metadata:
  name: cass-emp-svc
  labels:
    app: cass-emp-svc
spec:
  ports:
  - port: 5000
  selector:
    app: cass-emp-svc
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cass-emp-svc
spec:
  selector:
    matchLabels:
      app: cass-emp-svc
  replicas: 1
  template:
    metadata:
      labels:
        app: cass-emp-svc
    spec:
      containers:
      - image: salsanger/peoplesuite_apis:0.0.1-cass
        name: cass-emp-svc
        imagePullPolicy: Always #download image fresh for every deployment
        ports:
        - containerPort: 5000
          name: cass-emp-svc
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: employee-ingr
  # annotations:
    # nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  #ingressClassName: nginx-ingr
  ingressClassName: nginx
  rules:
  - host: localhost
    http:
      paths:
      - path: /employees
        pathType: Prefix
        backend:
          service:
            name: cass-emp-svc
            port:
              number: 5000

#selector chooses the pods, template describes how the pods are created
#env 
#doesn't matter what you call the deployment, it's looking for matchLabels
#k8 manifest: describes application
#yaml, deployment

#service already connected to deployment (right now, the yaml created the container/pods for us, but it's not exposed)
#needs an ingress to expose service
#An API object that manages external access to the services in a cluster, typically HTTP. (kubernetes.io)
#Ingress may provide load balancing, SSL termination and name-based virtual hosting (kubernetes.io)
#service (prob pod-scope) and ingress (prob cluster-scope) independantly do their own kind of load balancing

#rewrite target in the ingress annotation: changing the path comiung in to a different one (that's used internally)
#matching a path to a service

#now i need to work with the python file and add paths to the ingress !!!!!!!!!!!!!!!!!

#make a script 

#will need a 2nd dockerfile later to build departmentService